/*
 * The Blueprint revised.
 *
 * A basic concept of Nemo's design.
 */
my byte ah;
my byte al;
my word ax;
my int eax; /* int is an 'alias' to dword (32 bit) */
my dword ebx; /* dword is an 'alias' to int (32 bit) */
my qword rcx; /* qword (64 bit) */

/* I.
 *
 * Basic blubber.
 */
word times_two word
{
  /* %N would refer to the Nth argument */
  return %1 * 2;
  /* maybe that should be dollars? I don't know, I've been doing some NASM
   * lately. */
}

map times_two [1, 2, 3, 4, 5];

/* anonymous way */
map word fun word { return %1 * 2 } [1, 2, 3, 4, 5];   /* <-- I don't like that */
/* or */
map word word { return %1 * 2 } [1, 2, 3, 4, 5];
/* or (the fun keyword would stand for an anonymous function that, hm, I don't
 * known, takes an int and returns an int? */
map fun { return %1 * 2 } [1, 2, 3, 4, 5];
/* or even? */
map { return %1 * 2 } [1, 2, 3, 4, 5];
/* maybe blocks could be an anonymous functions that take an int and return an
 * int? Perl 6-like, kind of... What would the argument be? And the return value? */

/* II.
 *
 * Defining a function:
 *
 *   <return type> [function's name] [arg#1 type[, arg#n type]+]
 *   [OPTS opt#1[, opt#n]]
 *   { <stmts> }
 *
 * By not providing the function's name an anonymous function is created
 * instead.
 *
 * NOTE: Functions are top-class citizens. They are objects, like ints and the rest.
 *
 * Eg.:
 */
word concat byte, byte  /* function taking two (byte) arguments, and returning a word */
{
  return %1 << 8 | %2
}

/* Whereas this: */
word byte, byte
{
  return %1 << 8 | %2
}
/* would create an anonymous function */

/* III.
 *
 * Functions must return a value. C-like 'void' is not allowed.
 */
word { return 0xBEEF }
/* would create an anonymous function that returns a word, and doesn't take any
 * arguments (although doing so in the top-level is pointless) */
my word meat = word { return 0xBEEF };
/* That's more like it (function inlining? that'd be good) */
/* Definition: */
word word { return %1 }
/* would create an anonymous function that takes a word, and returns a word */

/* IV.
 *
 * Pushing to (concatenting) an array.
 */
my int[] arr = [1, 2, 3, 4, 5];
/* function like? */
push(arr, 6);
/* syntax like? */
push arr, 6;
/* even more syntax like? (concatenting) */
arr = arr # [6];
/* and */
arr #= [6];

/* V.
 *
 * Function options.
 */
any[] sort any[]
opts -r /* sort in reverse */
     -q /* try to use quicksort */
     -b /* try to use bubblesort */
{
  /* options should be regular, non-const variables inside the function's body, and of type
   * bool-like (byte?) so that ones can [ex|in]clude others */

  if r {
    /* reverse */
  } else {
    /* normal */
  }
}
/* then calling: */
sort [4, 2, 1, 5, 3];
/* would return a sorted array, whereas */
sort-r [4, 2, 1, 5, 3];
/* would return an array sorted in reverse order */

/* another example: */
word concat byte, byte
opts -r /* concat in reverse */
{
  if r {
    return %2 << 8 | %1;
  } else {
    return %1 << 8 | %2;
  }
}

/* Note: */
int func opts -meh { /* ... */ }
/* would create a function that could take three options, 'm', 'e' and 'h'.
 * and _not_ one option 'meh'. */

 /* VI.
  *
  * Declaring a variable that is/holds a function.
  */
 /* Function's 'type' goes like follows:
  *
  *   '<' return type [; arg#1 type[, arg#n type]+] [; -[a-zA-Z]+] '>'
  *
  * Eg. this:
  *
  *   <word; byte, byte; -n> could be a 'prototype'(?) to the function that takes two
  *   bytes and returns a word, and could take the -n option
  */
 /* The following: */
 my <word; byte, byte; -n> add = word byte, byte opts -n { return %1 + %2 };
 /* creates a variable called 'add' that holds an anonymous function which takes
  * two bytes, returns a word, and could take the -n option. */
 /* calling it would look like: */
 my word res = add 2, 2;

/* VII.
 *
 * Calling a function.
 */
/* Function defined as: */
word add byte, byte
{
  return %1 + %2;
}
/* would be nice to could have been called parenthesisless, like this: */
my word result = add 2, 4;
/* (which obviously would make the 'result' contain 6) */

/* BUT */
/* what about this? */
my <word; byte, byte> addf = add;
/* would it make 'addf' kind of an alias to 'add'? or would/should it call add
 * and complain about no arguments given (when 2 expected)? */
/* maybe something along these lines? */
my <word; byte, byte> addf = &add;
/* C-like calling a function (parenthesises required) would solve this mess,
 * but.. Hmmm... */
my <word; <byte; word>, byte> func;
/* 'func' is declared to be a function that takes two parameters, #1 a function, which takes a
 * word and returns a byte and #2 a byte, and returns a word. But, uhm... how to
 * initialize it? */
my <word; <byte; word>, byte> func = word <byte; word>, byte
{
  return %1(0x2468) << 8 | %2;
};
/* hm.. that seems like it.. */
/* I can see it go very cryptic very soon but... that's good! :P */

/* VIII.
 *
 * ML-like type inference.
 */
/* That would be wicked to have!.. */
my add = int int, int { return %1 + %2 };
my bed = word { return 0xBED };

/* IX.
 *
 * C-structs/ML-tuples
 */
/* Structs/tuples could be enclosed with '@<' and '>', I guess. */
/* Or the parser could be smart enough to distinguish between a struct/tuple and
 * a function ;) */
my @<string name, int age> John;
/* And accessing the fields: */
John.name = "John";
John.age  = 34;


/*
 * To be continued..
 */

