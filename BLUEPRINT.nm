/*
 * The Blueprint revised.
 *
 * A basic concept of Nemo's design.
 */

/*
 * Quick overview:
 *
 *   o  Strongly typed
 *   o  Half imperative, half functional
 *   o  C-like braces
 */

/* I.
 *
 * Basic blubber.
 */

/* the "int" type would be of an arbitrary precision */
/* "my" defines/declares a variable */
my int much = 3e127;
/* but! typedef'ed ints would be able to have Ada-like ranges */
/* ("typedef" and "lim" are keywords, "byte" is the new type's name, 0 is the
 * lower limit and 255 is the upper limit (both are inclusive)) */
typedef int uint8_t lim 0, 255;
typedef int  int8_t lim -127, -127;
typedef int byte    lim 0, 255;
typedef int word    lim 0, 65536;
typedef int bool    lim 0, 1;
typedef int months  lim 1, 12;
/* the limits probably shouldn't be just literals, but expressions */
my int lower_limit = 2;
my int upper_limit = 64;
typedef int custom lim lower_limit * 8, upper_limit - 1;

/* XXX: bitwise operations on non-typedefed/non-limited ints? */

/* the rest of default, primitive types */
my string motd = "hello, world";
my const real Mills = 1.30637788386308069; /* arbitrary precision? */
/* notice the keyword "const" */

/* II.
 *
 * Defining a function:
 *
 *   <return type> [function's name] [arg#1 type[, arg#n type]+]
 *   ["opts" opt#1[, opt#n]]
 *   { <stmts> }
 *
 * By not providing the function's name an anonymous function is created
 * instead.
 *
 * NOTE: Functions are top-class citizens. They are objects, like ints and the rest.
 *
 * NOTE#2: arguments inside the function are referenced by '%N', where N is the
 *         argument's position in the argument list
 *
 * Eg.:
 */

word concat byte, byte  /* function taking two (byte) arguments, and returning a word */
{
  return %1 << 8 | %2 /* semicolons are optional if the statement is last in the
  block */
}

/* Whereas this: */
word byte, byte
{
  return %1 << 8 | %2
}
/* would create an anonymous function (but doing so in the top-level is
 * completly pointless) */

/*
 * Function's prototype:
 *
 *   '{' [return type] [';' (arg#1 type[, arg#N type])+ [; opts]] '}'
 *
 * Eg.:
 *
 *   { int; int, int }  is a function that takes two ints, and returns an int
 *   { string }         is a function that takes no arguments and returns a
 *                      string
 *   { int;; aux }      is a function that takes no arguments, returns an int and
 *                      can take the "a", "u" and "x" options
 */

/* this would create a variable called 'concat' which would end up being a
 * function */
my { word; byte, byte } concat = word byte, byte {
  return %1 << 8 | %2;
}

/* III.
 *
 * Function options.
 */

word concat byte, byte
opts r /* reverse */
{
  /* options should be regular, non-const variables inside the function's body, and of type
   * bool-like (byte?) so that ones can [ex|in]clude others */

  if r {
    return %2 << 8 | %1;
  } else {
    return %1 << 8 | %2;
  }
}

/* Note: */
int func opts meh { /* ... */ }
/* would create a function that could take three options, 'm', 'e' and 'h'.
 * and _not_ one option 'meh'. */

/* IV.
 *
 * Calling a function.
 */

/* given a function: */
int add int, int
{
  return %1 + %2;
}
/* calling a function happens very much C-like, ie. the function's name,
 * parethesis and arguments inside */
my int result = add(2, 4);
/* (which obviously would make the 'result' contain 6) */

/* V.
 *
 * ML-like type inference.
 */

/* That would be wicked to have!.. */
my rand = { return 4; };
my beef = { return 0xbeef; };
/* both `rand' and `beef' would end up being functions */

/* XXX: inlining? */

/* VI.
 *
 * C-structs/ML-tuples
 */

/*
 * Tuples' prototypes:
 *
 *   '(' field#1 type and name [',' field#N type and name]+ ')'
 */

/* example: */
my (string name, int age) him = ("John", 34);
/* and then to access the fields: */
John.age  = 44; /* timeskip! */

/*
 * VII.
 *
 * Lists
 */

/*
 * Lists' prototypes:
 *
 *   '[' type ']'
 */

/* example: */
my [int] fib = [ 1, 1, 2, 3, 5, 8 ];
/* another, more cryptic, example (a list of tuples (where one of the fields
 * is a function)) */
my [(string cmd, { int; [string /* arguments */] } func)] = [
  ("cp", int [string] { /* do coppy stuff */ return 1; }),
  ("mv", int [string] { /* do movvy stuff */ return 1; }),
];

/*
 * VIII.
 *
 * Polymorphism.
 */

/*
 * In Nemo, the asterisk ('*') sign would stand for "any type", thus:
 *
 *    *     is any type (think: 'a)
 *   [*]    is a list of anything (think: 'a list)
 *   {*}    is a function that could return and take anything (think: f)
 *
 *   XXX: tuples?
 */

/* example: a function which was to count the number of elements in a list wouldn't
 * need to care of what type the list's elements are */
/* few examplanatory(?) functions: */

/* function that takes two arguments: #1 a function which returns anything and
 * takes anything (ie. we don't know what kind of function would be passed) and
 * #2 a list of anything */
my {[*]; {*}, [*]} map =
{
  return match %2 {
    [] => [];
    /* '*' in `match" matches everything, like a wildcard (think: `_') */
     * => %1(hd(%2)) :: map(%1, tl(%2));
     /* `hd' would fetch the list's head (first element) and `tl' would fetch the
      * list's tail (the whole list without the first element) */
  };
}

my {int; [*]} size =
{
  return match %1 {
    [] => 0;
     * => 1 + size(tl(%1));
  };
}

/*
 * To be continued..
 */

